#pragma once

#include <vector>
#include <bsoncxx/builder/stream/document.hpp>
#include <bsoncxx/json.hpp>
#include <bsoncxx/document/value.hpp>

#include "../entity/VcfRecord.h"

namespace vcf_tool::domain::dao {

/**
 * @brief MongoDB schema for VcfRecord with conversion utilities
 *
 * Document Structure:
 * {
 *   "_id": ObjectId (auto-generated by MongoDB),
 *   "chromosome": string,
 *   "position": int64,
 *   "ref": string,
 *   "alt": string,
 *   "data": {
 *     "FILTER": <json>,
 *     "QUAL": <json>,
 *     "INFO": <json>,
 *     "FORMAT": <json>
 *   }
 * }
 *
 * NOTE: Only stores VcfRecord fields (chromosome, position, ref, alt, data).
 * ParsedRecord metadata (line_number, raw_text) is NOT stored.
 *
 * The "_id" field is automatically generated by MongoDB as ObjectId.
 * The "data" field contains the flexible JSON data from VcfRecord.
 */
struct VcfSchema {
    /**
     * Convert VcfRecord to BSON document
     *
     * @param record  Source VCF record
     * @return BSON document ready for MongoDB insertion
     */
    static bsoncxx::document::value to_bson(const VcfRecord& record) {
        using bsoncxx::builder::stream::document;
        using bsoncxx::builder::stream::finalize;

        // Convert nlohmann::json to BSON by serializing to string first
        // Note: mongocxx doesn't have direct nlohmann::json support
        std::string json_str = record.data.dump();

        // Parse JSON string to BSON with error handling
        bsoncxx::document::value json_bson = [&json_str]() {
            try {
                return bsoncxx::from_json(json_str);
            } catch (...) {
                // If JSON parsing fails, use empty object
                document empty_obj{};
                return empty_obj << finalize;
            }
        }();

        // Build BSON document (MongoDB will auto-generate _id)
        document builder{};
        builder << "chromosome" << record.chromosome
                << "position" << static_cast<std::int64_t>(record.position)
                << "ref" << record.ref
                << "alt" << record.alt
                << "data" << json_bson.view();

        return builder << finalize;
    }

    /**
     * Batch convert multiple VcfRecords to BSON documents
     *
     * @param records  Vector of VcfRecords
     * @return Vector of BSON documents
     */
    static std::vector<bsoncxx::document::value> to_bson_batch(
        const std::vector<VcfRecord>& records)
    {
        std::vector<bsoncxx::document::value> bson_docs;
        bson_docs.reserve(records.size());

        for (const auto& record : records) {
            bson_docs.push_back(to_bson(record));
        }

        return bson_docs;
    }
};

} // namespace vcf_tool::domain::dao
